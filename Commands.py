import datetime as dt
import json
import random as r
import time
import requests

from pyrogram import Client, filters
from pyrogram.types import *

from ParseMode import *


class Commands:

    def __init__(self, client):
        self._client: Client = client

        timetable = requests.get("https://lyceum.nstu.ru/rasp/nika_data_06102021_215229.js", verify=False).text. \
            replace(
            "// nika_data.js;  description: schedule in JSON format\r\n"
            "// this file automatically generated by Nika-Soft(c) products\r\n \r\n"
            "var NIKA=\r\n",
            "").strip().replace(";", "")

        self._lastSeenDay: int = dt.datetime.today().day
        with open("Students.json", "r", encoding="utf-8") as file:
            self._dutiesList: List[dict[str: str]] = json.load(file)
        self._dutiesToday = self.GetRandomDuties()
        self._timetable = json.loads(timetable)

    def GetRandomDuties(self):
        first = self._dutiesList[r.randint(0, len(self._dutiesList) - 1)]
        second = self._dutiesList[r.randint(0, len(self._dutiesList) - 1)]

        return [first['Name'] + " " + first['Surname'], second['Name'] + " " + second['Surname']]

    async def ShowHelp(self, message: filters.Message):
        return await self._client.send_message(message.chat.id, "**Для просмотра дежурных** /work.\n"
                                                                "**Расписание** - /timetable.\n"
                                                                "**Когда я?** - /time \n"
                                                                "**Домашнее задание** - /hw.\n"
                                                                "**Демотиватор** - /black __--картинка--__.\n\n"
                                                                "**Сохранить домашнее задание в бота** -\n"
                                                                "/newhw __--день недели-- --предмет-- --картинка--__",
                                               parse_mode=ParseMode.Markdown,
                                               reply_markup=ReplyKeyboardMarkup([
                                                   [KeyboardButton("/work"), KeyboardButton("/timetable"),
                                                    KeyboardButton("/time")],
                                                   [KeyboardButton("/hw"), KeyboardButton("/black"),
                                                    KeyboardButton("/newhw")]
                                               ], resize_keyboard=True, one_time_keyboard=True))

    async def ShowDuties(self, message: filters.Message):
        todayDay = dt.datetime.today().day
        if self._lastSeenDay != todayDay:
            self._lastSeenDay = todayDay
            self._dutiesToday = self.GetRandomDuties()

        return await self._client.send_message(message.chat.id,
                                               f"Дежурные сегодня - **{', '.join(self._dutiesToday)}**",
                                               parse_mode=ParseMode.Markdown)

    async def ShowTimetable(self, message: filters.Message):
        subject = ""
        teacher = ""
        room = ""
        newTimetable = self._timetable
        dayNames = newTimetable['DAY_NAMES']
        weekday = dt.datetime.today().weekday() + 1
        result = f"{[dayNames[weekday] if i == weekday else 0 for i in range(0, len(dayNames) - 1)]}\n"
        number = 1

        for item in newTimetable['CLASS_SCHEDULE']['47']['029']:
            if int(item[0]) == weekday:
                for s in newTimetable['SUBJECTS']:
                    for ssg in newTimetable['CLASS_SCHEDULE']['47']['029'][item]['s']:
                        if s == ssg:
                            subject += newTimetable['SUBJECTS'][s].title()
                            break

                for t in newTimetable['TEACHERS']:
                    for tsg in newTimetable['CLASS_SCHEDULE']['47']['029'][item]['t']:
                        if t == tsg:
                            teacher += newTimetable['TEACHERS'][t].title()
                            break

                for r in newTimetable['ROOMS']:
                    for rsg in newTimetable['CLASS_SCHEDULE']['47']['029'][item]['r']:
                        if r == rsg:
                            room += newTimetable['ROOMS'][r].title() + " "
                            break

                if (number - 1) % 2 == 0:
                    result += f"**Пара {number // 2 + 1}**\n"
                result += f"{number}. {subject}(к. {room}) {teacher}\n"
                subject = ""
                teacher = ""
                room = ""
                number += 1

        return await self._client.send_message(message.chat.id, result, parse_mode=ParseMode.Markdown)

    async def ShowTime(self, message: filters.Message):
        return await self._client.send_message(message.chat.id,
                                               "Дата: **{:%m-%d-%y}** \n".format(dt.datetime.today()) +
                                               "Время: **{:%H:%M:%S}**".format(dt.datetime.today()),
                                               parse_mode=ParseMode.Markdown)

    async def ShowHomework(self, message: filters.Message):
        pass

    async def ShowBlack(self, message: filters.Message):
        await self._client.send_message(message.chat.id, "Called")
        # if message.photo:
        #     await self._client.download_media(message, r"aa.jpg")
        #
        # if message.reply_to_message:
        #     a = bytes(message.reply_to_message.photo.)
        #     await self._client.download_media(message.reply_to_message, r"aa.jpg")

    async def CreateHomework(self, message: filters.Message):
        pass

    async def Echo(self, message: filters.Message):
        textList = message.text.split(' ')
        if len(textList) < 4 or int(textList[1]) > 100 or int(textList[2]) > 20:
            return await self._client.send_message(message.chat.id, "**--Некорректный ввод!--**",
                                                   parse_mode=ParseMode.Markdown)

        duration = round(float(textList.pop(1))) if textList[1] else 0
        delay = float(textList.pop(1)) if textList[1] else 0

        for i in range(0, duration):
            time.sleep(delay)
            await self._client.send_message(message.chat.id, ' '.join(textList[1:]))
