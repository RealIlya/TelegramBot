import requests
from datetime import datetime

from pyrogram import Client, filters

from Stuff.Errors import *
from Stuff.Duties import *
from Stuff.Helper import *
from Stuff.ParseMode import *


class Commands:

    def __init__(self, client):
        self._GLOBAL_DELAY: float = 0.01

        self._client: Client = client
        self.duties: Duties = Duties()

        timetable = requests.get("https://lyceum.nstu.ru/rasp/nika_data_08102021_153342.js", verify=False).text. \
            replace(
            "// nika_data.js;  description: schedule in JSON format\r\n"
            "// this file automatically generated by Nika-Soft(c) products\r\n \r\n"
            "var NIKA=\r\n",
            "").strip().replace(";", "")

        self._dutiesToday = self.duties.GetRandomDuties()
        self._lastSeenDay: int = datetime.today().day
        self._timetable = json.loads(timetable)

    async def ShowHelp(self, message: filters.Message):
        return await self._client.send_message(message.chat.id, "**Для просмотра дежурных** /work.\n"
                                                                "**Расписание** - /timetable.\n"
                                                                "**Когда я?** - /time \n"
                                                                "**Домашнее задание** - /hw.\n"
                                                                "**Демотиватор** - /black __--картинка--__.\n\n"
                                                                "**Сохранить домашнее задание в бота** -\n"
                                                                "/newhw __--день недели-- --предмет-- --картинка--__",
                                               parse_mode=ParseMode.Markdown)

    async def ShowDuties(self, message: filters.Message):
        todayDay = datetime.today().day
        if self._lastSeenDay != todayDay:
            self._lastSeenDay = todayDay
            self._dutiesToday = self.duties.GetRandomDuties()

        return await self._client.send_message(message.chat.id,
                                               f"Дежурные сегодня - **{', '.join(self._dutiesToday)}**",
                                               parse_mode=ParseMode.Markdown)

    async def ShowTimetable(self, message: filters.Message):
        textList = message.text.split(' ')
        newTimetable = self._timetable
        dayNames = [day.title() for day in newTimetable['DAY_NAMES']]
        presentWeekday = datetime.today().weekday() + 1
        result = "--{0}--\n".format(textList[1].title() if len(textList) > 1 else dayNames[presentWeekday - 1])
        number = 1
        condition = dayNames.index(textList[1].title()) + 1 if len(textList) > 1 else presentWeekday

        for item in newTimetable['CLASS_SCHEDULE']['47']['029']:
            if int(item[0]) == condition:
                subjects = [newTimetable['SUBJECTS'][subject].title() for subject in newTimetable['SUBJECTS']
                            for ssg in newTimetable['CLASS_SCHEDULE']['47']['029'][item]['s'] if subject == ssg]

                teachers = [newTimetable['TEACHERS'][teacher].title() for teacher in newTimetable['TEACHERS']
                            for tsg in newTimetable['CLASS_SCHEDULE']['47']['029'][item]['t'] if teacher == tsg]

                rooms = [newTimetable['ROOMS'][room].title() for room in newTimetable['ROOMS']
                         for rsg in newTimetable['CLASS_SCHEDULE']['47']['029'][item]['r'] if room == rsg]

                if (number - 1) % 2 == 0:
                    result += f"**Пара {number // 2 + 1}**\n"
                result += f"{number}. {' / '.join(subjects)}({' / '.join(rooms)})\n     {' / '.join(teachers)}\n"
                number += 1

        return await self._client.send_message(message.chat.id, result, parse_mode=ParseMode.Markdown)

    async def ShowTime(self, message: filters.Message):
        return await self._client.send_message(message.chat.id,
                                               "Дата: **{:%m-%d-%y}** \n".format(datetime.today()) +
                                               "Время: **{:%H:%M:%S}**".format(datetime.today()),
                                               parse_mode=ParseMode.Markdown)

    async def ShowHomework(self, message: filters.Message):
        pass

    async def ShowBlack(self, message: filters.Message):
        await self._client.send_message(message.chat.id, "Called")
        # if message.photo:
        #     await self._client.download_media(message, r"aa.jpg")
        #
        # if message.reply_to_message:
        #     a = bytes(message.reply_to_message.photo.)
        #     await self._client.download_media(message.reply_to_message, r"aa.jpg")

    async def CreateHomework(self, message: filters.Message):
        pass

    async def Echo(self, message: filters.Message):
        textList = message.text.split(' ')
        if len(textList) < 4 or int(textList[1]) > 100 or float(textList[2]) > 20:
            return await Errors.PrintError(message, "Недопустимая длина/задержка!")

        duration = round(float(textList.pop(1))) if textList[1] else 0
        delay = float(textList.pop(1)) if textList[1] else 0

        return [await Helper.SetDelay(delay, message.reply_text, ' '.join(textList[1:])) for _ in range(0, duration)]

    async def Repeat(self, message: filters.Message):
        text = " " + message.reply_to_message.text if message.reply_to_message else message.text
        textList = text.split(' ')
        if len(textList) < 2 or len(text) > 25:
            return await Errors.PrintError(message, "Недопустимая длина!")

        return [await Helper.SetDelay(self._GLOBAL_DELAY, message.reply_text, letter) for letter in
                ''.join(textList[1:])]

    async def Ghoul(self, message: filters.Message):
        startMessage = await self._client.send_message(message.chat.id, "1000")

        return [await Helper.SetDelay(self._GLOBAL_DELAY, startMessage.edit_text, str(i if i > 0 else "я гуль"))
                for i in range(993, -30, -7)]
