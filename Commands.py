import datetime as dt
import json
import random as r
import time
import requests

from pyrogram import Client, filters
from pyrogram.types import *

from ParseMode import *


class Commands:

    def __init__(self, client):
        self._client: Client = client

        timetable = requests.get("https://lyceum.nstu.ru/rasp/nika_data_07102021_210817.js", verify=False).text. \
            replace(
            "// nika_data.js;  description: schedule in JSON format\r\n"
            "// this file automatically generated by Nika-Soft(c) products\r\n \r\n"
            "var NIKA=\r\n",
            "").strip().replace(";", "")

        self._lastSeenDay: int = dt.datetime.today().day
        with open("Students.json", "r", encoding="utf-8") as file:
            self._dutiesList: List[dict[str: str]] = json.load(file)
        self._dutiesToday = self.GetRandomDuties()
        self._timetable = json.loads(timetable)

    def PrintError(self, message, messageError):
        return self._client.send_message(message.chat.id, "**--{0}--**".format(messageError),
                                         parse_mode=ParseMode.Markdown)

    def GetRandomDuties(self):
        first = self._dutiesList[r.randint(0, len(self._dutiesList) - 1)]
        second = self._dutiesList[r.randint(0, len(self._dutiesList) - 1)]

        return [first['Name'] + " " + first['Surname'], second['Name'] + " " + second['Surname']]

    async def ShowHelp(self, message: filters.Message):
        return await self._client.send_message(message.chat.id, "**Для просмотра дежурных** /work.\n"
                                                                "**Расписание** - /timetable.\n"
                                                                "**Когда я?** - /time \n"
                                                                "**Домашнее задание** - /hw.\n"
                                                                "**Демотиватор** - /black __--картинка--__.\n\n"
                                                                "**Сохранить домашнее задание в бота** -\n"
                                                                "/newhw __--день недели-- --предмет-- --картинка--__",
                                               parse_mode=ParseMode.Markdown)

    async def ShowDuties(self, message: filters.Message):
        todayDay = dt.datetime.today().day
        if self._lastSeenDay != todayDay:
            self._lastSeenDay = todayDay
            self._dutiesToday = self.GetRandomDuties()

        return await self._client.send_message(message.chat.id,
                                               f"Дежурные сегодня - **{', '.join(self._dutiesToday)}**",
                                               parse_mode=ParseMode.Markdown)

    async def ShowTimetable(self, message: filters.Message):
        textList = message.text.split(' ')
        newTimetable = self._timetable
        dayNames = [day.title() for day in newTimetable['DAY_NAMES']]
        presentWeekday = dt.datetime.today().weekday() + 1
        result = "--{0}--\n".format(textList[1].title() if len(textList) > 1 else dayNames[presentWeekday - 1])
        number = 1
        condition = dayNames.index(textList[1].title()) + 1 if len(textList) > 1 else presentWeekday

        for item in newTimetable['CLASS_SCHEDULE']['47']['029']:
            if int(item[0]) == condition:
                subjects = [newTimetable['SUBJECTS'][subject].title() for subject in newTimetable['SUBJECTS']
                            for ssg in newTimetable['CLASS_SCHEDULE']['47']['029'][item]['s'] if subject == ssg]

                teachers = [newTimetable['TEACHERS'][teacher].title() for teacher in newTimetable['TEACHERS']
                            for tsg in newTimetable['CLASS_SCHEDULE']['47']['029'][item]['t'] if teacher == tsg]

                rooms = [newTimetable['ROOMS'][room].title() for room in newTimetable['ROOMS']
                         for rsg in newTimetable['CLASS_SCHEDULE']['47']['029'][item]['r'] if room == rsg]

                if (number - 1) % 2 == 0:
                    result += f"**Пара {number // 2 + 1}**\n"
                result += f"{number}. {' / '.join(subjects)}({' / '.join(rooms)})\n     {' / '.join(teachers)}\n"
                number += 1

        return await self._client.send_message(message.chat.id, result, parse_mode=ParseMode.Markdown)

    async def ShowTime(self, message: filters.Message):
        return await self._client.send_message(message.chat.id,
                                               "Дата: **{:%m-%d-%y}** \n".format(dt.datetime.today()) +
                                               "Время: **{:%H:%M:%S}**".format(dt.datetime.today()),
                                               parse_mode=ParseMode.Markdown)

    async def ShowHomework(self, message: filters.Message):
        pass

    async def ShowBlack(self, message: filters.Message):
        await self._client.send_message(message.chat.id, "Called")
        # if message.photo:
        #     await self._client.download_media(message, r"aa.jpg")
        #
        # if message.reply_to_message:
        #     a = bytes(message.reply_to_message.photo.)
        #     await self._client.download_media(message.reply_to_message, r"aa.jpg")

    async def CreateHomework(self, message: filters.Message):
        pass

    async def Echo(self, message: filters.Message):
        textList = message.text.split(' ')
        if len(textList) < 4 or int(textList[1]) > 100 or float(textList[2]) > 20:
            return await self.PrintError(message, "Недопустимая длина!")

        duration = round(float(textList.pop(1))) if textList[1] else 0
        delay = float(textList.pop(1)) if textList[1] else 0

        for i in range(0, duration):
            time.sleep(delay)
            await self._client.send_message(message.chat.id, ' '.join(textList[1:]))

    async def Repeat(self, message: filters.Message):
        text = " " + message.reply_to_message.text if message.reply_to_message else message.text
        textList = text.split(' ')
        if len(textList) < 2 or len(text) > 50:
            return await self.PrintError(message, "Недопустимая длина!")

        for word in textList[1:]:
            for letter in word:
                time.sleep(0.5)
                await self._client.send_message(message.chat.id, letter)
